---
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;灯具进销存系统
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 详细设计描述文档
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V1.0 正式版

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CuteGroup 
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2017-11-14
---
### 目录
1、引言  
	1.1、编制目的  
	1.2、词汇表  
	1.3、参考资料  
2、产品概述  
3、体系结构设计概述  
4、结构视角   
5、依赖视角  
  

  
## 1. 引言

###### &nbsp;&nbsp;&nbsp;&nbsp; 1.1 编制目的
&nbsp;&nbsp;&nbsp;&nbsp;本报告详细完成对灯具进销存系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。  
&nbsp;&nbsp;&nbsp;&nbsp;本报告面向开发人员，测试人员及最终用户而编写，是了解系统的导航。  

###### &nbsp;&nbsp;&nbsp;&nbsp;1.2词汇表
|词汇名称 |词汇含义| 备注|  
|---|---|---|  
|_ui|表示某展示层||  
|_bl|表示某逻辑层||  
|_data|表示某数据层||  

###### &nbsp;&nbsp;&nbsp;&nbsp;1.3 参考资料
1、灯具进销存系统需求规格说明文档  
2、灯具进销存系统用例文档  
3、灯具进销存系统体系结构描述文档
  
## 2. 产品概述
&nbsp;&nbsp;&nbsp;&nbsp;参考灯具进销存系统用例文档和灯具进销存系统软件需求规格说明中对产品的概括描述。

  
## 3.体系结构设计概述
&nbsp;&nbsp;&nbsp;&nbsp;参考灯具进销存系统概要设计文档中对体系结构设计的概述。
  
## 4.结构视角
  
  
###4.1 业务逻辑层的分解
  
### 4.1.1 goods 模块
#### （1）模块描述
goodsbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
goodsbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加GoodsBLService接口。业务逻辑层和数据层之间添加GoodsDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了GoodsBLServiceImpl，这样GoodsBLServiceImpl会将对新建的业务逻辑处理委托给Goods和GoodsCategory对象。GoodsPO和GoodsCategoryPO是作为商品和商品分类信息的持久化对象被添加到设计模型中去的。<br/>

goodsbl模块的设计如图4.1.1-1 所示

  
![](https://i.imgur.com/MbzkqFu.png)
**图 4.1.1（1）-1 goodsbl模块设计模型**<br/>

表 4.1.1-1（2） goodsbl模块各个类的职责<br/>

模块 | 职责
---|---
GoodsBLServiceImpl | 管理goodsbl各个类的任务
Goods | 完成对商品信息的增删改查任务
GoodsCategory | 完成对商品分类信息的增删改查任务

#### （3）模块内部类的接口规范
GoodsBLServiceImpl 的接口规范如表4.1.1（3）-1所示。<br/>
Goods的接口规范如表4.1.1（3）-2所示。<br/>
GoodsCategory的接口规范如表4.1.1（3）-3所示。<br/>

表4.1.1（3）-1 GoodsBLServiceImpl的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.newGoods</td>
<td>语法</td> <td> public String newGoods(String name,String category);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示商品名称和编号</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.findGoods</td>
<td>语法</td> <td> public List<GoodsVO> findGoods(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的商品列表</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.deleteGoods</td>
<td>语法</td> <td> public ResultMessage deleteGoods(String id);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品列表</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.modifyGoods</td>
<td>语法</td> <td> public ResultMessage modifyGoods(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.initAndSaveGoods</td>
<td>语法</td> <td>public ResultMessage initAndSaveGoods(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户保存已初始化的商品信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.newGoodsCategory</td>
<td>语法</td> <td>public ResultMessage newGoodsCategory(String category,String node);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.deleteGoodsCategory</td>
<td>语法</td> <td>public ResultMessage deleteGoodsCategory(String category);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.modifyGoodsCategory</td>
<td>语法</td> <td>public ResultMessage modifyGoodsCategory(String category);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品分类名称</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.getAllGoodsAndCategory</td>
<td>语法</td> <td>public TreeVO getAllGoodsAndCategory();</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看所有分类和所有商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示所有分类和所有商品</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>Goods.newGoods(String name,String category)</td> <td>新建商品</td>
</tr>
<tr>
<td>Goods.findGoods(String info,String type)</td> <td>模糊查找商品</td>
</tr>
<tr>
<td>Goods.deleteGoods(String id)</td> 
<td>删除商品</td>
</tr>
<tr>
<td>Goods.modifyGoods(GoodsVO vo)</td> 
<td>修改商品信息</td>
</tr>
<tr>
<td>Goods.initAndSaveGoods(GoodsVO vo)</td> 
<td>初始化并保存商品信息</td>
</tr>
<tr>
<td>GoodsCategory.newGoodsCategory(String category,String node)</td> 
<td>新建商品分类</td>
</tr>
<tr>
<td>GoodsCategory.deleteGoodsCategory(String category)</td> 
<td>删除商品分类</td>
</tr>
<tr>
<td>GoodsCategory.modifyGoodsCategory(String category)</td> 
<td>修改商品分类名</td>
</tr>
<tr>
<td>GoodsCategory.getAllGoodsAndCategory()</td> 
<td>获取所有商品分类和商品</td>
</tr>
</table>

表4.1.1（3）-2 Goods 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">Goods.newGoods</td>
<td>语法</td> <td> public String newGoods(String name,String category);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示商品名称和编号</td>
</tr>
<tr>
<td rowspan="3">Goods.findGoods</td>
<td>语法</td> <td> public List<GoodsVO> findGoods(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的商品列表</td>
</tr>
<tr>
<td rowspan="3">Goods.deleteGoods</td>
<td>语法</td> <td> public ResultMessage deleteGoods(String id);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品列表</td>
</tr>
<tr>
<td rowspan="3">Goods.modifyGoods</td>
<td>语法</td> <td> public ResultMessage modifyGoods(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品信息</td>
</tr>
<tr>
<td rowspan="3">Goods.initAndSaveGoods</td>
<td>语法</td> <td>public ResultMessage initAndSaveGoods(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户保存已初始化的商品信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品信息</td>
</tr>
</table>
<table>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>GoodsDataService.newGoods(String name,String category)</td> <td>新建商品</td>
</tr>
<tr>
<td>GoodsDataService.findGoods(String info,String type)</td> <td>模糊查找商品</td>
</tr>
<tr>
<td>GoodsDataService.deleteGoods(String id)</td> 
<td>删除商品</td>
</tr>
<tr>
<td>GoodsDataService.modifyGoods(GoodsVO vo)</td> 
<td>修改商品信息</td>
</tr>
<tr>
<td>GoodsDataService.initAndSaveGoods(GoodsVO vo)</td> 
<td>初始化并保存商品信息</td>
</tr>
</table>

表 4.1.1(3)-3 GoodsCategory 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<tr>
<td rowspan="3">GoodsCategory.newGoodsCategory</td>
<td>语法</td> <td>public ResultMessage newGoodsCategory(String category,String node);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.deleteGoodsCategory</td>
<td>语法</td> <td>public ResultMessage deleteGoodsCategory(String category);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.modifyGoodsCategory</td>
<td>语法</td> <td>public ResultMessage modifyGoodsCategory(String category);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品分类名称</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.getAllGoodsAndCategory</td>
<td>语法</td> <td>public TreeVO getAllGoodsAndCategory();</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看所有分类和所有商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示所有分类和所有商品</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>GoodsDataService.newGoodsCategory(String category,String node)</td> 
<td>新建商品分类</td>
</tr>
<tr>
<td>GoodsDataService.deleteGoodsCategory(String category)</td> 
<td>删除商品分类</td>
</tr>
<tr>
<td>GoodsDataService.modifyGoodsCategory(String category)</td> 
<td>修改商品分类名</td>
</tr>
<tr>
<td>GoodsDataService.getAllGoodsAndCategory()</td> 
<td>获取所有商品分类和商品</td>
</tr>
</table>

#### (4)业务逻辑层的动态模型
图4.1.1（4）-1表明了进销存系统中，当用户选择新建商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/TCUyFnJ.png)
**图4.1.1（4）-1增加商品**<br/>

图4.1.1（4）-2表明了进销存系统中，当用户模糊查找商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/0R54oIc.png)
**图4.1.1（4）-2模糊查找商品**<br/>

图4.1.1（4）-3表明了进销存系统中，当用户删除商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
  
![](https://i.imgur.com/kPAfwQh.png)
**图4.1.1（4）-3删除商品**<br/>

图4.1.1（4）-4表明了进销存系统中，当用户修改商品信息时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/MdYKBjw.png)
**图4.1.1（4）-4修改商品信息**<br/>

图4.1.1（4）-5表明了进销存系统中，当用户初始化并保存商品信息时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/jk15Gr3.png)
**图4.1.1（4）-5初始化商品信息并保存**<br/>

图4.1.1（4）-6表明了进销存系统中，当用户新建商品分类时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/kB7ABC6.png)
**图4.1.1（4）-6新建商品分类**<br/>

图4.1.1（4）-7表明了进销存系统中，当用户删除商品分类时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/WzMHMTI.png)
**图4.1.1（4）-7删除商品分类**<br/>

图4.1.1（4）-8表明了进销存系统中，当用户修改商品分类名称时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/4xr2L4C.png)
**图4.1.1（4）-8修改商品分类**<br/>

图4.1.1（4）-9表明了进销存系统中，当用户查看所有分类和商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/8yJ7A0d.png)
**图4.1.1（4）-9查看所有分类和商品**<br/>

图4.1.1（4）-10所示的状态图描述Goods对象的生存期间的状态序列、引起转移的事件、以及因状态转移而伴随的动作。随着initAndSaveGoods/newGoods/findGoods/deleteGoods/modifyGoods方法被GoodsBLServiceImpl调用，Goods进入handleData状态；之后通过获取GoodsPO进入Present状态；通过获取ResultMessage进入Complete状态<br/>
![](https://i.imgur.com/vslx0e2.png)
**图4.1.1（4）-10 Goods对象状态图**<br/>

图4.1.1（4）-11所示的状态图描述GoodsCategory对象的生存期间的状态序列、引起转移的事件、以及因状态转移而伴随的动作。随着newGoodsCategory/deleteGoodsCategory/modifyGoodsCategory/getAllGoodsAndCategory方法被GoodsBLServiceImpl调用，GoodsCategory进入handleData状态；之后通过获取GoodsPO进入Present状态；通过获取ResultMessage进入Complete状态<br/>
![](https://i.imgur.com/ffh22xW.png)
**图4.1.1（4）-11 GoodsCategory对象状态图**<br/>  
  
  
### 4.1.2 VIP 模块
#### （1）模块描述
VIPbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
VIPbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加VIPBLService接口。业务逻辑层和数据层之间添加VIPDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了VIPBLServiceImpl，这样VIPBLServiceImpl会将对新建的业务逻辑处理委托给VIP对象。VIPPO是作为商品和商品分类信息的持久化对象被添加到设计模型中去的。<br/>
  
**图4.1.2-1**
![](https://i.imgur.com/laZa3L0.png)  


VIPbl模块的设计如图4.1.2-1 所示

表 4.1.2-1（2） VIPbl模块各个类的职责<br/>

模块 | 职责
---|---
VIPBLServiceImpl | 管理VIPbl各个类的任务
VIP | 完成对客户信息的增删改查任务

#### （3）模块内部类的接口规范
VIPBLServiceImpl 的接口规范如表4.1.2（3）-1所示。<br/>
VIP的接口规范如表4.1.2（3）-2所示。<br/>

表4.1.2（3）-1 VIPBLServiceImpl的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.newGoods</td>
<td>语法</td> <td> public String newVIP(String telephone);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示客户电话和编号</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.findVIP</td>
<td>语法</td> <td> public ArrayList<VIPVO> findVIP(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的客户列表</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.deleteVIP</td>
<td>语法</td> <td> public ResultMessage deleteVIP(String id);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户列表</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.modifyVIP</td>
<td>语法</td> <td> public ResultMessage modifyVIP(VIPVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户信息</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.initAndSaveVIP</td>
<td>语法</td> <td>public ResultMessage initAndSaveVIP(VIPVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户保存已初始化的客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户信息</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.getVIPInfo</td>
<td>语法</td> <td>public ArrayList<VIPVO> getVIPInfo();</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看所有客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示所有客户信息</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>VIP.newVIP(String telephone)</td> <td>新建会员</td>
</tr>
<tr>
<td>VIP.findVIP(String info)</td> <td>模糊查找会员</td>
</tr>
<tr>
<td>VIP.deleteVIP(String id)</td> 
<td>删除会员</td>
</tr>
<tr>
<td>VIP.modifyVIP(VIPVO vo)</td> 
<td>修改会员信息</td>
</tr>
<tr>
<td>VIP.initAndSaveVIP(VIPVO vo)</td> 
<td>初始化并保存客户信息</td>
</tr>
<tr>
<td>VIP.getVIPInfo()</td> 
<td>获取所有客户信息</td>
</tr>
</table>

表4.1.2（3）-2 VIP 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">VIP.newGoods</td>
<td>语法</td> <td> public String newVIP(String telephone);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示客户电话和编号</td>
</tr>
<tr>
<td rowspan="3">VIP.findVIP</td>
<td>语法</td> <td> public ArrayList<VIPVO> findVIP(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的客户列表</td>
</tr>
<tr>
<td rowspan="3">VIP.deleteVIP</td>
<td>语法</td> <td> public ResultMessage deleteVIP(String id);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户列表</td>
</tr>
<tr>
<td rowspan="3">VIP.modifyVIP</td>
<td>语法</td> <td> public ResultMessage modifyVIP(VIPVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户信息</td>
</tr>
<tr>
<td rowspan="3">VIP.initAndSaveVIP</td>
<td>语法</td> <td>public ResultMessage initAndSaveVIP(VIPVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户保存已初始化的客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户信息</td>
</tr>
<tr>
<td rowspan="3">VIP.getVIPInfo</td>
<td>语法</td> <td>public ArrayList<VIPVO> getVIPInfo();</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看所有客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示所有客户信息</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>VIPDataService.newVIP(String telephone)</td> <td>新建会员</td>
</tr>
<tr>
<td>VIPDataService.findVIP(String info)</td> <td>模糊查找会员</td>
</tr>
<tr>
<td>VIPDataService.deleteVIP(String id)</td> 
<td>删除会员</td>
</tr>
<tr>
<td>VIPDataService.modifyVIP(VIPVO vo)</td> 
<td>修改会员信息</td>
</tr>
<tr>
<td>VIPDataService.initAndSaveVIP(VIPVO vo)</td> 
<td>初始化并保存客户信息</td>
</tr>
<tr>
<td>VIPDataService.getVIPInfo()</td> 
<td>获取所有客户信息</td>
</tr>
</table>

#### (4)业务逻辑层的动态模型
图4.1.2（4）-1表明了进销存系统中，当用户选择初始化并保存客户信息时，客户业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/wgZ2Vfu.png)
**图4.1.2（4）-1初始化并保存客户信息**<br/>

图4.1.2（4）-2所示的状态图描述VIP对象的生存期间的状态序列、引起转移的事件、以及因状态转移而伴随的动作。随着initAndSaveVIP/newVIP/VIP/modifyVIP方法被VIPBLServiceImpl调用，VIP进入handleData状态；之后通过获取VIPPO进入Present状态；通过获取ResultMessage进入Complete状态<br/>  

  
![](https://i.imgur.com/qCpY2bb.png)  
  

**图4.1.2（4）-2 VIP对象状态图**<br/>


  
### 4.1.3 sale 模块
#### （1）模块描述
salebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求</br>
salebl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加SaleBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了 SaleBLServiceImpl，这样SaleBLBLServiceImpl会将针对多种单据的业务逻辑交给SaleForAll对象，会将针对销售单的业务逻辑处理交给SaleList对象，将针对销售退货单的业务逻辑处理交给SaleReturnList对象，将针对进货单的业务逻辑处理交给StockList对象，将针对进货退货单的业务逻辑处理交给StockReturnList对象，将针对所有单据共同部分的业务逻辑处理交给SalesmanList对象。而Bill和SaleItem的添加是GoodsVO的容器类。SalesmanListVO,SaleListVO,SaleReturnListVO,StockListVO,StockReturnListVO是作为销售人员单据的值对象被添加到设计模型中去的，GoodsVO是作为商品信息的值对象被添加到设计模型中去的，VIPVO是作为会员信息的值对象被添加到设计模型中去的，PresentResultVO是作为销售人员所需的使用赠送策略结果的值对象被添加到设计模型中的，SaleVO是作为生成赠送策略所需的销售单信息的值对象被添加到设计模型中的，SalesmanListPO,SaleListPO,SaleReturnListPO,StockListPO,StockReturnListPO是作为销售人员单据的持久化对象被添加到设计模型中去的。<br/>

salebl模块的设计如图4.1.2-1 所示

![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/7574bc97d00f78386a5736e9da1886066e0fdab3/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/salebl%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**图 4.1.3（1）-1 salebl模块设计模型**<br/>

表 4.1.3-1（2） salebl模块各个类的职责<br/>

模块 | 职责
---|---
SaleBLServiceImpl|管理整合SaleBL各个类的任务，负责与其他bl模块交互 
SaleForAll | 负责协助处理涉及多种销售人员单据的服务
StockList | 负责协助处理涉及进货单的服务
StockReturnList | 负责协助处理涉及进货退货单的服务
SaleList | 负责协助处理涉及销售单的服务
SaleReturnList | 负责协助处理涉及销售退货单的服务
SalesmanList | 负责处理所有单据共同部分的服务，如获得会员信息，获得商品信息，记录操作日志
Bill | 负责计算总价和赠送策略
SaleItem | 负责计算小计

#### （3）模块内部类的接口规范
SaleBLServiceImpl的接口规范参见体系结构文档<br/>
SaleForAll,StockList,StockReturnList,SaleList,SaleReturnList的接口规范参见体系结构文档<br/>
表 SaleItem 的接口规范<br/>
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<tr>
<td rowspan="3">SaleItem.modifyQuantity</td>
<td>语法</td> <td>public ResultMessage modifyQuantity(String goodsid, int quantity);</td>
</tr>
<tr>
<td>前置条件</td> <td>商品存在</td>
</tr>
<tr>
<td>后置条件</td><td>改变数量</td>
</tr>
<tr>
<td rowspan="3">SaleItem.getTotal</td>
<td>语法</td> <td>public ResultMessage getTotal();</td>
</tr>
<tr>
<td>前置条件</td> <td>商品存在且数量存在</td>
</tr>
<tr>
<td>后置条件</td><td>返回小计</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>GoodsInfo.getGoods</td> 
<td>获得商品信息</td>
</tr>
</table>

表 Bill 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<tr>
<td rowspan="3">Bill.refresh</td>
<td>语法</td> <td>public Bill refresh(DateUtil date, List<SaleItem>, String memberId, int sum);</td>
</tr>
<tr>
<td>前置条件</td> <td>单据中存在会员，商品名，商品数量等信息</td>
</tr>
<tr>
<td>后置条件</td><td>返回原价、使用的促销策略和总价</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>SaleItem.getTotal</td> 
<td>获得表单商品的价格小计</td>
</tr>
</tr>
<tr>
<td>PresentBLInfo.findPresent</td> 
<td>获得促销策略</td>
</tr>
</table>

#### (4)业务逻辑层的动态模型

图4.1.3（4）-1表明了进销存系统中，当用户删除单据时，销售业务逻辑处理的相关对象之间的协作。其他同理。<br/>
![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/master/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/%E5%88%A0%E9%99%A4%E9%94%80%E5%94%AE%E7%B1%BB%E5%8D%95%E6%8D%AE.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**图4.1.3（4）-1删除单据**<br/>
![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/master/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/Sale%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E5%9B%BE.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**图4.1.3（4）-2 Sale对象状态图**<br/>
### 4.1.4 List模块  

####(1)模块描述
listbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求  
listbl模块的职责及接口参见软件系统体系结构描述文档  

####(2)整体结构
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加ListBLService接口。业务逻辑层和数据层之间添加ListDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了ListBLServiceImpl，这样ListBLServiceImpl会将对新建的业务逻辑处理委托给accountList,presidentList,saleList,storeList,otherList对象。ListPO是作为表单（目录）类信息的持久化对象被添加到设计模型中去的。<br/>

Listbl 模块的详细设计类图如图4.1.4-1所示  
  
**图4.1.4-1**  
![](https://i.imgur.com/4bCC0hs.png)
  
  
表4.1.4(2)  listbl 模块各个类的职责  
  
|模块|职责|
|----|---|
|ListblserviceImpl|负责实现Listblservice接口所需要的表单查看、表单审批、表单导出功能，并将具体任务分派给模块内其他各类|
|accountList|负责实现财务类单据（付款单，收款单，现金费用单）的查看、审批、导出功能|
|presentList|负责实现库存赠送单的查看、审批、导出功能|
|salesList|负责实现销售单、进货单、销售退货单、进货退货单的查看、审批、导出功能|
|storeList|负责实现库存类单据（报损单、报溢单、报警单）的查看、审批、导出功能|
|otherList|负责实现销售明细表、经营情况表的查看、审批、导出功能。|
|message|负责实现表单审批后的消息发送功能。|

####（3）模块内部类的接口规范  
  
表4.1.4（3）-1a   listblserviceImpl类的供接口  

|服务编号|项目|内容|
|---|---|---|
|listblserviceImpl.approve|语法| public ResultMessage approve (ListType type，String id)|
|  |前置条件|用户选择审批某个表单|
|  |后置条件|系统更新该表单的审批信息|
|listblserviceImpl.openList|语法|public List<ListVO> openList(ListType type)|
|  |前置条件|用户选择查看某类表单|
|  |后置条件|系统显示该类表单的列表|
|listblserviceImpl.opensingleList|语法|public ListVO openSingleList(ListType type)|
|  |前置条件|用户选择查看销售明细表或经营情况表|
|  |后置条件|系统显示该表单|
|listblserviceImpl.toExcelFile|语法|public String (ListType type,String id)|
|  |前置条件|用户选择导出表单|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败)|

表4.1.4（3）-1b   listblserviceImpl类的需接口   
 
|需要的服务名|需要的服务内容|
|---|----|
|accountList.approve|审批财务类单据|
|accountList.openList|打开财务类单据列表|
|accountList.toEcelFile|导出财务类单据|
|storeList.approve|审批库存类单据|
|storeList.openList|打开库存类单据列表|
|storeList.toEcelFile|导出库存类单据|
|salesList.approve|审批销售、进货类单据|
|salesList.openList|打开销售、进货单据列表|
|salesList.toEcelFile|导出销售、进货类单据|
|presentList.approve|审批赠送类单据|
|presentList.openList|打开赠送类单据列表|
|presentList.toEcelFile|导出赠送类单据|
|otherList.openList|打开其他类单据列表|
|otherList.toEcelFile|导出其他类单据|

**由于对各类经营历程表（包括销售、赠送、库存、账户）的查看、审批、导出的具体操作非常类似，下面我们只选取财务类单据来代表这4类单据的查看、审批、导出流程。**
    
  

表4.1.4（3）-2a accountList类的供接口  

 
|服务编号|项目|内容|  
|----|--|---|
|accountList.approve|语法|public ResultMessage approve (ListType type，String id)|
|  |前置条件|用户选择审批某个账户类表单|
|  |后置条件|系统更新该表单的审批信息|
|accountList.openList|语法|public List<ListVO> openList(ListType type)|  
|  |前置条件|用户选择查看账户类表单中的某类具体表单|
|  |后置条件|系统显示该类表单的列表|
|accountList.toExcelFile|语法|public String toExcelFile (ListType type,ListVO vo)|
|  |前置条件|用户选择导出表单|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败）|

  
表4.1.4（3）-2b accountList类的需接口  

|需要的服务名|需要的服务内容|
|---|---|
|account.accountlist.openCommitted|获取已提交的账户类单据数据|
|account.accountlist.save|保存更改后的单据信息|
|user.message.save|向财务人员发送消息|

  
表4.1.4（3）-3a otherList 类的供接口  
  

|服务编号 |项目|内容 |
|-----|---|----|
|otherList.openSingleList|语法| public ResultMessage openSingleList (ListType type，String id)|
|  |前置条件|用户选择审批某个账户类表单|
|  |后置条件|系统更新该表单的审批信息|
|otherList.toExcelFile|语法|public String (ListType type,String id)|
|  |前置条件|用户选择导出表单|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败）|
|otherList.modify|语法|public ListRM modify (ListType type , ListVO vo)|
|  |前置条件|该单据已经在数据库中被新建并初始化|
|  |后置条件|当发生销售等行为，系统自动对数据库中的单据数据进行修改|
  
  
表4.1.4（3）-3b otherList 类的需接口
  
|需要的服务名|需要的服务内容|
|-----|-----|
|listdataservice.get|获取销售明细表、经营情况表的信息|
|listdataservice.save|保存销售明细表、经营情况表的信息| 
  
####(4)业务逻辑层的动态模型
  
表单包中查看、审批、导出文件操作中，表示相关对象协作的顺序图由图4.1.4（4）-1表示

图4.1.4（4）-1
![](https://i.imgur.com/o4dG058.png)

表单包中各个表单对象的状态图在图4.1.4（4）-2中给出，在图中，对象被初始化后根据得到的信息和命令进入不同的状态，包括查看状态、审批状态、导出状态，在结束单次操作后对象生命期结束。

图4.1.4（4）-2  
![](https://i.imgur.com/RkujUWw.png)  
  
  
####（5）业务逻辑层的设计原理  
  利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域的对象。并通过向外提供接口避免了循环依赖的问题。其他设计原理从略。
  
  
  
  
### 4.1.5 User 模块
#### （1）模块描述
Userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
Userbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
在体系结构的设计基础上，进一步将层间接口细化，按照接口最小化原则将UserBLService接口拆分成PersonalInfoService，SystemManagerServicec，OperationLogService三部分，并分别用PersonalInfo，SystemManager，OperationLog三个业务逻辑对象实现它们。也将UserDataService拆分成MessageDataService，UserDataService，OperationDataService三部分。  

User模块的设计如图4.1.5-1 所示

![](doc/md/详细设计文档/User模块的详细设计方案.png)

**图 4.1.5（1）-1 Userbl模块设计模型**<br/>

表 4.1.5-1（2） Userbl模块各个类的职责<br/>

模块 | 职责
---|---
PersonalInfo| 完成个人用户所需的功能
SystemManager | 完成系统管理员所需的功能
OperationLog | 完成日志有关的功能  
Message|完成消息有关的功能  


#### （3）模块内部类的接口规范
PersonalInfo 的接口规范如表4.1.5（3）-1所示。  
SystemManager的接口规范如表4.1.5（3）-2所示。  
OperationLog的接口规范如表4.1.5（3）-3所示。  
Message的接口规范如表4.1.5（3）-4所示。  



表4.1.5（3）-1 PersonalInfo的接口规范

与体系结构描述文档中如下接口相同  
public ResultMessage login(String name, String password)   
public ResultMessage logout()   
public UserVO getCurrentUserInfo()	  
public ResultMessage changePassword(String oldPassword,String newPassword)   
public List<MessageVO> checkMessage()   

表4.1.5（3）-2 SystemManger的接口规范

与体系结构描述文档中如下接口相同  
public String newUser(String name)   
public ResultMessage initAndSave(UserVO vo)   
public ResultMessage delete(String id)   
public ResultMessage modify(UserVO vo)   
public List<UserVO> findUser(String info)   


表4.1.5（3）-3 OperationLog 的接口规范

<table>
<tr>
<td colspan ="3">提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan = "3">saveOperation</td>
<td>语法</td><td>public ResultMessage saveOperation(OperationVO)</td>
</tr>
<tr>
<td>前置条件</td><td> 经理或财务人员已登陆 </td>
</tr>
<tr>
<td>后置条件</td><td>返回日志信息</td>
</tr>
</table>

以及体系结构描述文档中如下接口  
public List<OperationVO> viewLog()  


表 4.1.5(3)-4 Message 的接口规范

<table>
<tr>
<td colspan ="3">提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan = "3">sendMessage</td>
<td>语法</td><td>public ResultMessage sendMessage(MessageVO vo, UserRole role)
</td>
</tr>
<tr>
<td>前置条件</td><td> 经理或财务人员已登陆 </td>
</tr>
<tr>
<td>后置条件</td><td>返回日志信息</td>
</tr>
<tr>
<td rowspan = "3">checkMessage</td>
<td>语法</td><td>public List<MessageVO> checkMessage(String id)</td>
</tr>
<tr>
<td>前置条件</td><td>完成一个完整操作</td>
</tr>
<tr>
<td>后置条件</td><td>持久化保存操作记录</td>
</tr>
</table>


#### (4)业务逻辑层的动态模型
图4.1.5（4）表明了进销存系统中，当用户登录以及查看消息时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/jJwW2wx.png)

**图4.1.5（4）登录和增加商品**<br/>

其他的顺序图与此类似，在此不再赘述    
  
  
  
  
###4.1.6 Store模块
####(1)模块描述
storebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求  
storebl模块的职责及接口参见软件系统体系结构描述文档  
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加StoreBLService接口。业务逻辑层和数据层之间添加StoreDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了StoreBLServiceImpl，这样StoreBLServiceImpl会将对新建的业务逻辑处理委托给store_check,store_inventory,overflow_report_List,loss_report_List,presentList对象。StorePO是作为表单（目录）类信息的持久化对象被添加到设计模型中去的。<br/>

Listbl 模块的详细设计类图如图4.1.6-1所示  
  
![](https://i.imgur.com/qQLCiTU.png)
  
  
表4.1.4(2)  listbl 模块各个类的职责  
  
|模块|职责|
|---|----|
|StoreblserviceImpl|负责实现Storeblservice接口所需要的库存报损、库存报溢、库存赠送、库存查看、库存盘点功能，并将具体任务分派给模块内其他各类|
|overflow_report_List|负责实现库存报溢单的生成、提交等功能|
|loss_report_List|负责实现库存报损单的生成、提交等功能|
|presentList|负责实现库存赠送单的生成、提交等功能。|
|store_check|负责实现库存查看功能，向库存管理人员反应库存情况。|
|store_inventory|负责实现库存盘点功能，并支持信息的Excel导出。|
|message|负责实现表单审批后的消息发送功能。|
|AlarmList|自动生成库存报警单，并向库存管理人员发送消息|
|dataChange|负责处理库存类单据过审、商品和商品分类变动造成的库存数据变化|
  
  
####（3）模块内部类的接口规范  
  
表4.1.6（3）-1a   storeblserviceImpl类的供接口  

|服务编号|项目|内容|
|---|---|---|
|storeblserviceImpl.openReportList|语法|public List<\ReportListVO> openReportList(ListType lt，StateType st) | 
|  |前置条件|用户选择查看报告类单据，包括报损类、报溢类的草稿单、待审批单、通过单、未通过单|
|  |后置条件|系统显示该类表单的列表|
|storeblserviceImpl.openAlarmList|语法|public List <\AlarmListVO> openAlarmList()|
|  |前置条件|用户选择查看报警单列表|
|  |后置条件|系统显示该类表单的列表|
|storeblserviceImpl.openPresentList|语法|public List<\PresentListVO> openPresentList(StateType st)|
|  |前置条件|用户选择查看赠送单列表，可选择的状态为草稿单、待审批单、通过单、未通过单|
|  |后置条件|系统显示该类表单的列表|
|storeblserviceImpl.toExcelFile|语法|public String toExcel(	InventoryVO vo)|
|  |前置条件|用户选择导出当天的库存盘点，生成Excel文件|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败）|
|storeblserviceImpl.newList|语法|public String newList(ListType type)|
|  |前置条件|用户选择新建单据|
|  |后置条件|系统自动计算并返回单据编号|
|storeblserviceImpl.saveReportList|语法|public ListRM saveReportList (ListType type , ListVO vo)|
|  |前置条件|用户选择保存报损或者报溢出类单据|
|  |后置条件|系统将该单据数据保存在草稿箱|
|storeblserviceImpl.savePresentList|语法|public ListRM savePresentList ( ListVO vo)|
|  |前置条件|用户选择保存赠送类单据|
|  |后置条件|系统将该单据数据保存在草稿箱|
|storeblserviceImpl.commit|语法|public ListRM commit (ListType type , String ID)|
|  |前置条件|用户选择提交某类型的单据|
|  |后置条件|系统将该单据提交，并更新单据状态为已经提交，并在表单类的已提交单据信息表中注册该单据的信息。（若该单据尚未保存在数据库，则界面层应先调用保存方法，再提交）|
|storeblserviceImpl.check|语法| public storeCheckVO store_check(String begintime,String endTime)|
|  |前置条件|用户设置查看时间段，并查看该时段的各类库存信息，具体信息项见用例文档|
|  |后置条件|系统返回该时间段内的各类库存信息|
|storeblserviceImpl.inventory|语法|public storeInventoryVO store_inventory(String day)|
|  |前置条件|用户设置查询日期，对该天进行库存查看|
|  |后置条件|系统返回该日的库存盘点结果|
  
  
表4.1.6（3）-1b   listblserviceImpl类的需接口   
 
|需要的服务名|需要的服务内容|
|---|----|
|storeDataService.insertItem|插入单项商品的库存信息|
|storeDataService.insertList|插入表单信息|
|storeDataService.modifyItem|修改单项商品的库存信息|
|storeDataService.modifyList|修改单项表单的表单信息|
|storeDataService.deleteItem|删除单项商品的库存信息记录|
|storeDataService.deleteList|删除单项表单的表单内容记录|
|storeDataService.findItem|查找某项库存记录|
|storeDataService.findList|查找某项表单|
|storeDataService.calcID|计算某类单据新建时的编号|

**由于库存单据（报损、报溢、赠送）所有操作均相同，只有VO\PO中的数据项意义略有区别，故而只选择库存报损单来说明供接口和需接口。**  
表4.1.6（3）-2a loss_report_List类的供接口   
 
|服务编号|项目|内容|
|---|---|---|
|loss_report_List.new|语法| public String new ()|
|  |前置条件|用户选择新建库存报损单|
|  |后置条件|系统计算单据编号并返回|
|loss_report_List.openList|语法|public List<\ListVO> openList()|
|  |前置条件|用户选择查看库存报损单，入口参数是单据状态，包括草稿单、待审批单、审批通过单、审批未过单|
|  |后置条件|系统显示该类表单的列表|
|loss_report_List.delete|语法|public ResultMessage delete (String ID)|
|  |前置条件|用户选择删除某项记录|
|  |后置条件|系统显示删除信息|
|loss_report_List.save|语法| public ListRM save （ReportListVO vo）|
|  |前置条件|用户选择保存某个单据至数据库|
|  |后置条件|系统显示操作是否成功|
|loss_report_List.commit|语法|public ListRM commit(String ID)|
|  |前置条件|用户选择提交某张单据|
|  |后置条件|系统将该单据提交，并更新单据状态为已经提交，并在表单类的已提交单据信息表中注册该单据的信息。|


  
表4.1.6（3）-2b accountList类的需接口   
 
|需要的服务名|需要的服务内容|
|----|---|
|storeDataService.insertList|插入表单信息|
|storeDataService.modifyList|修改单项表单的表单信息|
|storeDataService.deleteList|删除单项表单的表单内容记录|
|storeDataService.findList|查找某项表单|
|storeDataService.calcID|计算某类单据新建时的编号|
|listblservice.addListInfo|添加已提交单的信息|
  

  
表4.1.6（3）-3a store_inventory 类的供接口  
  

|服务编号|项目|内容|
|---|---|---|
|store_inventory.inventory|语法| public storeInventoryVO store_inventory(String day)|
|  |前置条件|用户选择进行库存盘点，并输入了要盘点的日期|
|  |后置条件|系统返回该日期库存各项数据的统计，统计的项见用例文档|
|store_inventory.toExcel|语法|public String toExcel(	InventoryVO vo)|
|  |前置条件|用户选择导出当天的库存盘点，生成Excel文件|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败）|
  
表4.1.6（3）-3b store_inventory 类的需接口  

|需要的服务名|需要的服务内容|
|---|----|  
|storeDataService.findItem|查找某项库存记录|  
  
表4.1.6（3）-4a store_check 类的供接口  
  

|服务编号|项目|内容|
|---|---|---|
|store_check.inventory|语法| public storeCheckVO store_check(String begin ,String end)|
|  |前置条件|用户选择进行库存盘点，并输入了要盘点的日期|
|  |后置条件|系统返回该日期库存各项数据的统计，统计的项见用例文档 |

表4.1.6（3）-4b store_check 类的需接口  

|需要的服务名|需要的服务内容|
|---|----|  
|storeDataService.findItem|查找某项库存记录|
  
  
表4.1.6（3）-5a dataChange类的供接口    

|服务编号|项目|内容|
|---|---|---|
|dataChange.new|语法| public dataChangeRM newItem (String name,int number)|
|  |前置条件|商品类新建了某项商品，并初始化了其库存值|
|  |后置条件|调用数据层接口，更新数据库|
|dataChange.delete|语法| public dataChangeRM deleteItem (String name) |
|  |前置条件|商品类删除了某商品，从而清空其库存记录|
|  |后置条件|调用数据层接口，删除该库存项的记录|
|dataChange.modify|语法|public dataChangeRM modifyItem (String name,int number )|
|  |前置条件|某种商品数量因为某种操作被修改|
|  |后置条件|系统更新数据库|
|dataChange.changeItemName|语法| public dataChangeRM changeItemName（String old,String new)|
|  |前置条件|某种商品名称被修改，或更换了分类|
|  |后置条件|系统更新数据库中的商品名字|
|dataChange.checkAlarm|语法|public dataChangeRM checkAlarm (String name,int number)|
|  |前置条件|用户做了某项将要更改库存数量的操作|
|  |后置条件|系统自动检查库存是否少于警戒线，若操作后低于警戒线，但库存依然为正，则允许该操作，并调用库存报警单的方法，生成报警单，并向库存管理员发送消息。若操作后库存为负，则直接拒绝该操作。|
  
表4.1.6（3）-5b dataChange类的需接口  

|需要的服务名|需要的服务内容|
|----|---|
|storeDataService.insertItem|插入库存记录|
|storeDataService.modifyItem|修改单项库存记录|
|storeDataService.deleteItem|删除单项库存记录|
|storeDataService.findItem|查找单项库存记录|  
|AlarmList.alarmCheck|库存报警检验|
  
  
  
####(4)业务逻辑层的动态模型
  
库存包中库存盘点、库存报告表示相关对象协作的顺序图由图4.1.6（4）-1表示：  
    
图4.1.6（4）-1
![](https://i.imgur.com/uxSIvcf.png)  
  
库存包中各个对象的状态图在图4.1.6（4）-2中给出，在图中，对象被初始化后根据得到的信息和命令进入不同的状态，包括增加状态、删除状态、修改状态、查找状态、计算状态，在结束单次操作后对象生命期结束。
  
图4.1.6（4）-2
 
![](https://i.imgur.com/qE4NRcz.png)  
  

####（5）业务逻辑层的设计原理  
  利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域的对象。并通过向外提供接口避免了循环依赖的问题。其他设计原理从略。
  

### 4.1.7 Account 模块
#### （1）模块描述
Accountbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
Accountbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
在体系结构的设计基础上，进一步将层间接口细化，按照接口最小化原则将AccountBLService接口拆分成FinanceListService，AccountManagerServicec，AccountInitService三部分，并分别用FinanceListServiceControllor，AccountManagement，AccountInit三个业务逻辑对象实现它们。其中，FinanceListServiceControllor又会将任务委托给具体的list类来处理。也将AcountDataService拆分成PaymentListDataService，CollectionListDataService，CashExpenseListDataService,AccountDataService四部分。   

Account模块的设计如图4.1.5-1 所示

![](doc/md/详细设计文档/Account模块的详细设计方案.png)

**图 4.1.5（1）-1 Accountbl模块设计模型**<br/>

表 4.1.5-1（2） Accountbl模块各个类的职责<br/>

模块 | 职责
---|---
FinanceListServiceControllor|统一控制与财务类单据相关的操作  
FinanceList|完成与三种单据都相关的功能   
AccountManagement|实现与账户管理有关的功能    
AccountInit|完成与期初建账有关的功能  
PaymentList|完成与付款单有关的功能  
CollectionList|完成与收款单有关的功能  
CashExpenseList|完成与现金费用单有关的功能  

#### （3）模块内部类的接口规范
FinanceListServiceControllor 的接口参见原型代码  
AccountManagement  的接口参见原型代码   
AccountInit  的接口参见原型代码 
PaymentList，CollectionList，CashExpenseList的接口同各种单据的通用接口，详细参见体系结构描述文档   

表4.1.7（3）-1 Financelist  的接口规范

<table>
<tr>
<td colspan ="3">提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan = "3">OpenDraft</td>
<td>语法</td><td>public List<FinanceListVO> openDraft()</td>
</tr>
<tr>
<td>前置条件</td><td> 财务人员已登陆</td>
</tr>
<tr>
<td>后置条件</td><td>返回所有财务类草稿单列表</td>
</tr>
<tr>
<td rowspan = "3">OpenCommitted</td>
<td>语法</td><td>public List<FinanceListVO> openCommitted()</td>
</tr>
<tr>
<td>前置条件</td><td> 财务人员已登陆</td>
</tr>
<tr>
<td>后置条件</td><td>返回所有财务类已提交单列表</td>
</tr>
<tr>
<td rowspan = "3">findVIP</td>
<td>语法</td><td>public List<VIPVO> findVIP(String info)</td>
</tr>
<tr>
<td>前置条件</td><td>无</td>
</tr>
<tr>
<td>后置条件</td><td>返回符合关键词的会员列表</td>
</tr>
<tr>
<td rowspan = "3">findAccount</td>
<td>语法</td><td>public List<AccountVO> findAccount()</td>
</tr>
<tr>
<td>前置条件</td><td>无</td>
</tr>
<tr>
<td>后置条件</td><td>返回所有账户列表</td>
</tr>
</table>


### 4.1.8 Present 模块
#### （1）模块描述
presentbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求</br>
presentbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加PresentBLService接口。业务逻辑层和数据层之间添加PresentDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了PresentBLServiceImpl，这样PresentBLServiceImpl会将处理多种赠送策略的业务逻辑交给PresentForAll对象，将处理针对用户级别型赠送策略的业务逻辑交给PresentForMembership对象，将处理特价包型赠送策略的业务逻辑交给PresentForSpecialPackage对象，将处理针对总价型赠送策略的业务逻辑交给PresentForSum对象。在Present模块和Sale模块之间，我们添加了PresentInfo接口和PresentInfoImpl对象。这样PresentInfoImpl对象会将改变PresentResult领域对象的任务委派给PresentForMembershipHandler对象，PresentForSpecialPackageHandler对象和PresentForSumHandler对象。PresentVO,PresentForMembershipVO,PresentForSpecialPackageVO,PresentForSumVO是作为不同种策略的值对象，PresentResultVO是作为为销售模块提供的赠送策略信息的值对象，SaleVO是作为销售模块提供的赠送策略所需的值对象，PresentForMembershipPO,PresentForSpecialPackagePO,PresentForSumPO是作为不同种策略的持久化对象被添加到设计模型中去的。<br/>

presentbl模块的设计如图4.1.2-1 所示

![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/master/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/presentbl%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**presentbl模块设计模型**<br/>

表 presentbl模块各个类的职责<br/>

模块 | 职责
---|---
PresentBLServiceImpl | 管理控制PresentBL中负责增删改查服务的类
PresentForAll | 负责协助处理涉及多种赠送策略增删改查的服务
PresentForMembership | 负责协助处理针对用户级别的赠送策略增删改查的业务逻辑
PresentForSpecialPackage | 负责协助处理特价包型的赠送策略增删改查的业务逻辑
PresentForSum  | 负责协助处理针对总价的赠送策略增删改查的业务逻辑
PresentInfoImpl | 负责控制PresentBL中负责使用销售策略的类
PresentForMembershipHandler | 负责使用针对用户级别的赠送策略
PresentForSpecialPackageHandler | 负责使用特价包型的赠送策略
PresentForSumHandler | 负责使用针对总价的赠送策略
PresentResult | 销售模块所需的使用赠送策略结果的领域对象
#### （3）模块内部类的接口规范
PresentBLServiceImpl的接口规范<br>
参见体系结构文档中Present业务逻辑层模块的接口规范，后置条件为委托给接口对应的PresentForAll,PresentForMembership,PresentForSpecialPackage,PresentForSum类

PresentForAll,PresentForMembership,PresentForSpecialPackage,PresentForSum类的接口规范<br>
参见PresentBLServiceImpl中对应的接口规范，方法名与PresentServiceImpl相同

PresentInfo的接口规范如下表<br>
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">PresentInfo.findPresent</td>
<td>语法</td> <td> public PresentResultVO findPresent(SaleVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>无</td>
</tr>
<tr>
<td>后置条件</td><td>调用PresentResultImpl的findPresent方法</td>
</tr>
<tr>
</table>

PresentResultImpl的接口规范如下表<br>
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">PresentResultImpl.handle</td>
<td>语法</td> <td> public PresentResultVO handle(VIPGrade grade);</td>
</tr>
<tr>
<td>前置条件</td> <td>无</td>
</tr>
<tr>
<td>后置条件</td><td>按顺序调用PresentForSpecialPackage,PresentForSum,PresentForMembership的handle方法
<tr>
</table>

PresentForSpecialPackage,PresentForSum,PresentForMembership的供接口为各模块的handle方法，入口参数为对应的salevo中的参数</br>
PresentResult的供接口为各属性的setter</br>
PresentDataService的接口同体系结构文档对应接口</br>
<table>


  
## 5.依赖视角  

图5.1和图5.2是客户端和服务器端各自的包之间的依赖关系。  
  
**图5.1  客户端包图**  

![](https://i.imgur.com/cLdt8oK.png)
    
 
**图5.2   服务器端包图**  
  
![](https://i.imgur.com/GabBxGf.png)
